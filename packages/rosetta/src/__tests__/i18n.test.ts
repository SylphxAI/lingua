/**
 * Additional tests for server/i18n.ts - Coverage for uncovered lines
 *
 * Note: Many Rosetta class methods are already tested in server.test.ts.
 * This file adds coverage for less-tested paths and edge cases.
 *
 * @module
 */

import { beforeEach, describe, expect, it } from 'bun:test';
import { InMemoryCache, type CacheAdapter } from '../cache';
import { Rosetta } from '../server/i18n';
import type { SourceString, SourceWithStatus, StorageAdapter, TranslateAdapter } from '../types';

// ============================================
// Mock Storage Adapter
// ============================================

interface TranslationData {
	text: string;
	autoGenerated: boolean;
	reviewed: boolean;
}

/**
 * Create a minimal mock storage that doesn't have getSourcesWithTranslations
 */
function createMinimalMockStorage(): StorageAdapter {
	const sources = new Map<string, { text: string; hash: string; context?: string }>();
	const translations = new Map<string, Map<string, TranslationData>>();

	return {
		async getTranslations(locale: string) {
			const localeData = translations.get(locale) ?? new Map();
			const result = new Map<string, string>();
			for (const [hash, data] of localeData) {
				result.set(hash, data.text);
			}
			return result;
		},

		async saveTranslation(locale, hash, text, options) {
			if (!translations.has(locale)) {
				translations.set(locale, new Map());
			}
			translations.get(locale)!.set(hash, {
				text,
				autoGenerated: options?.autoGenerated ?? false,
				reviewed: false,
			});
		},

		async getSources(): Promise<SourceString[]> {
			return Array.from(sources.values()).map((s) => ({
				text: s.text,
				hash: s.hash,
				context: s.context,
			}));
		},

		async getUntranslated(locale) {
			const localeTranslations = translations.get(locale) ?? new Map();
			return Array.from(sources.values())
				.filter((s) => !localeTranslations.has(s.hash))
				.map((s) => ({
					text: s.text,
					hash: s.hash,
					context: s.context,
				}));
		},

		async getAvailableLocales() {
			return Array.from(translations.keys());
		},

		// Helper methods for testing
		_insertSource(hash: string, text: string, context?: string) {
			sources.set(hash, { hash, text, context });
		},
	} as StorageAdapter & { _insertSource: (hash: string, text: string, context?: string) => void };
}

/**
 * Create a full mock storage with getSourcesWithTranslations
 */
function createFullMockStorage(): StorageAdapter & {
	_insertSource: (hash: string, text: string, context?: string) => void;
	_getTranslations: () => Map<string, Map<string, TranslationData>>;
} {
	const sources = new Map<string, { text: string; hash: string; context?: string }>();
	const translations = new Map<string, Map<string, TranslationData>>();

	return {
		_insertSource(hash: string, text: string, context?: string) {
			sources.set(hash, { hash, text, context });
		},

		_getTranslations() {
			return translations;
		},

		async getTranslations(locale: string) {
			const localeData = translations.get(locale) ?? new Map();
			const result = new Map<string, string>();
			for (const [hash, data] of localeData) {
				result.set(hash, data.text);
			}
			return result;
		},

		async getTranslationsByHashes(locale: string, hashes: string[]) {
			const localeData = translations.get(locale) ?? new Map();
			const result = new Map<string, string>();
			for (const hash of hashes) {
				const data = localeData.get(hash);
				if (data) {
					result.set(hash, data.text);
				}
			}
			return result;
		},

		async saveTranslation(locale, hash, text, options) {
			if (!translations.has(locale)) {
				translations.set(locale, new Map());
			}
			translations.get(locale)!.set(hash, {
				text,
				autoGenerated: options?.autoGenerated ?? false,
				reviewed: false,
			});
		},

		async getSources(): Promise<SourceString[]> {
			return Array.from(sources.values()).map((s) => ({
				text: s.text,
				hash: s.hash,
				context: s.context,
			}));
		},

		async getUntranslated(locale) {
			const localeTranslations = translations.get(locale) ?? new Map();
			return Array.from(sources.values())
				.filter((s) => !localeTranslations.has(s.hash))
				.map((s) => ({
					text: s.text,
					hash: s.hash,
					context: s.context,
				}));
		},

		async getSourcesWithTranslations(locales: string[]): Promise<SourceWithStatus[]> {
			return Array.from(sources.values()).map((source) => {
				const translationsResult: Record<
					string,
					{ text: string | null; autoGenerated: boolean; reviewed: boolean } | null
				> = {};
				for (const locale of locales) {
					const localeData = translations.get(locale);
					const t = localeData?.get(source.hash);
					translationsResult[locale] = t
						? { text: t.text, autoGenerated: t.autoGenerated, reviewed: t.reviewed }
						: null;
				}
				return {
					id: source.hash,
					text: source.text,
					hash: source.hash,
					context: source.context,
					translations: translationsResult,
				};
			});
		},

		async markAsReviewed(locale: string, hash: string) {
			const localeData = translations.get(locale);
			if (localeData?.has(hash)) {
				const data = localeData.get(hash)!;
				localeData.set(hash, { ...data, reviewed: true });
			}
		},

		async deleteTranslation(locale: string, hash: string) {
			translations.get(locale)?.delete(hash);
		},

		async deleteSource(hash: string) {
			sources.delete(hash);
			for (const localeData of translations.values()) {
				localeData.delete(hash);
			}
		},

		async getAvailableLocales() {
			return Array.from(translations.keys());
		},
	};
}

// Mock translator adapter
function createMockTranslator(): TranslateAdapter {
	return {
		async translate(text, options) {
			return `[${options.to}] ${text}`;
		},

		async translateBatch(texts, options) {
			return texts.map((item) => `[${options.to}] ${item.text}`);
		},
	};
}

// Mock failing translator adapter
function createFailingTranslator(): TranslateAdapter {
	return {
		async translate() {
			throw new Error('Translation failed');
		},
		async translateBatch() {
			throw new Error('Batch translation failed');
		},
	};
}

// ============================================
// getStorage
// ============================================

describe('Rosetta.getStorage()', () => {
	it('returns the storage adapter', () => {
		const storage = createFullMockStorage();
		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });

		expect(rosetta.getStorage()).toBe(storage);
	});
});

// ============================================
// Cache Integration
// ============================================

describe('Rosetta with cache', () => {
	it('uses cache for loadTranslations', async () => {
		const storage = createFullMockStorage();
		await storage.saveTranslation('zh-TW', 'hash1', '你好');

		const cache = new InMemoryCache({ ttlMs: 60000 });
		const rosetta = new Rosetta({ storage, cache, defaultLocale: 'en' });

		// First load - should hit storage and cache
		const translations1 = await rosetta.loadTranslations('zh-TW');
		expect(translations1.get('hash1')).toBe('你好');
		expect(await cache.has('zh-TW')).toBe(true);

		// Second load - should hit cache (we can verify by modifying storage)
		await storage.saveTranslation('zh-TW', 'hash2', '世界');
		const translations2 = await rosetta.loadTranslations('zh-TW');
		// Should NOT have hash2 because it's cached
		expect(translations2.has('hash2')).toBe(false);
	});

	it('invalidateCache clears cache', async () => {
		const storage = createFullMockStorage();
		await storage.saveTranslation('zh-TW', 'hash1', '你好');

		const cache = new InMemoryCache({ ttlMs: 60000 });
		const rosetta = new Rosetta({ storage, cache, defaultLocale: 'en' });

		// Load to populate cache
		await rosetta.loadTranslations('zh-TW');
		expect(await cache.has('zh-TW')).toBe(true);

		// Invalidate
		await rosetta.invalidateCache('zh-TW');
		expect(await cache.has('zh-TW')).toBe(false);
	});

	it('invalidateCache does nothing without cache', async () => {
		const storage = createFullMockStorage();
		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });

		// Should not throw
		await rosetta.invalidateCache('zh-TW');
		await rosetta.invalidateCache();
	});
});

// ============================================
// loadTranslationsByHashes
// ============================================

describe('Rosetta.loadTranslationsByHashes()', () => {
	it('loads only specified hashes using getTranslationsByHashes', async () => {
		const storage = createFullMockStorage();
		await storage.saveTranslation('zh-TW', 'hash1', '你好');
		await storage.saveTranslation('zh-TW', 'hash2', '世界');
		await storage.saveTranslation('zh-TW', 'hash3', '測試');

		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });
		const translations = await rosetta.loadTranslationsByHashes('zh-TW', ['hash1', 'hash3']);

		expect(translations.get('hash1')).toBe('你好');
		expect(translations.get('hash3')).toBe('測試');
		expect(translations.has('hash2')).toBe(false);
	});

	it('uses fallback chain for loadTranslationsByHashes', async () => {
		const storage = createFullMockStorage();
		await storage.saveTranslation('zh', 'hash1', '你好(简体)');
		await storage.saveTranslation('zh-TW', 'hash1', '你好(繁體)');
		await storage.saveTranslation('zh', 'hash2', '世界(简体)');

		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });
		const translations = await rosetta.loadTranslationsByHashes('zh-TW', ['hash1', 'hash2']);

		// hash1 should be from zh-TW (more specific)
		expect(translations.get('hash1')).toBe('你好(繁體)');
		// hash2 should fallback to zh
		expect(translations.get('hash2')).toBe('世界(简体)');
	});

	it('falls back to getTranslations when getTranslationsByHashes not available', async () => {
		const storage = createMinimalMockStorage();
		(storage as unknown as { _insertSource: (h: string, t: string) => void })._insertSource(
			'hash1',
			'Hello'
		);
		await storage.saveTranslation('zh-TW', 'hash1', '你好');
		await storage.saveTranslation('zh-TW', 'hash2', '世界');

		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });
		const translations = await rosetta.loadTranslationsByHashes('zh-TW', ['hash1']);

		// Should have all translations because it falls back to getTranslations
		expect(translations.get('hash1')).toBe('你好');
		expect(translations.get('hash2')).toBe('世界');
	});
});

// ============================================
// getClientData
// ============================================

describe('Rosetta.getClientData()', () => {
	it('returns all data needed for client hydration', async () => {
		const storage = createFullMockStorage();
		await storage.saveTranslation('zh-TW', 'hash1', '你好');

		const rosetta = new Rosetta({
			storage,
			defaultLocale: 'en',
			localeDetector: () => 'zh-TW',
		});

		const clientData = await rosetta.getClientData();

		expect(clientData.locale).toBe('zh-TW');
		expect(clientData.defaultLocale).toBe('en');
		expect(clientData.availableLocales).toContain('zh-TW');
		expect(clientData.translations).toEqual({ hash1: '你好' });
	});
});

// ============================================
// saveTranslation with validation
// ============================================

describe('Rosetta.saveTranslation() validation', () => {
	it('throws for invalid locale', async () => {
		const storage = createFullMockStorage();
		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });

		await expect(rosetta.saveTranslation('invalid', 'Hello', '你好')).rejects.toThrow(
			'Invalid locale'
		);
	});

	it('throws for non-string text', async () => {
		const storage = createFullMockStorage();
		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });

		await expect(
			rosetta.saveTranslation('zh-TW', 123 as unknown as string, '你好')
		).rejects.toThrow('Invalid input');
	});

	it('throws for non-string translation', async () => {
		const storage = createFullMockStorage();
		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });

		await expect(
			rosetta.saveTranslation('zh-TW', 'Hello', 123 as unknown as string)
		).rejects.toThrow('Invalid input');
	});

	it('throws for invalid context type', async () => {
		const storage = createFullMockStorage();
		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });

		await expect(
			rosetta.saveTranslation('zh-TW', 'Hello', '你好', 123 as unknown as string)
		).rejects.toThrow('Invalid context');
	});

	it('accepts valid inputs with context', async () => {
		const storage = createFullMockStorage();
		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });

		await rosetta.saveTranslation('zh-TW', 'Submit', '提交', 'form.button');

		const translations = await storage.getTranslations('zh-TW');
		expect(translations.size).toBe(1);
	});
});

// ============================================
// saveTranslationByHash validation
// ============================================

describe('Rosetta.saveTranslationByHash() validation', () => {
	it('throws for invalid hash', async () => {
		const storage = createFullMockStorage();
		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });

		await expect(rosetta.saveTranslationByHash('zh-TW', 'invalid-hash', '你好')).rejects.toThrow(
			'Invalid hash'
		);
	});

	it('validates sourceText when provided', async () => {
		const storage = createFullMockStorage();
		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });

		await expect(
			rosetta.saveTranslationByHash('zh-TW', 'abc123', '你好', {
				sourceText: 123 as unknown as string,
			})
		).rejects.toThrow('Invalid input');
	});

	it('accepts valid inputs', async () => {
		const storage = createFullMockStorage();
		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });

		await rosetta.saveTranslationByHash('zh-TW', 'abc123', '你好', {
			sourceText: 'Hello',
			autoGenerated: true,
		});

		const translations = await storage.getTranslations('zh-TW');
		expect(translations.get('abc123')).toBe('你好');
	});
});

// ============================================
// getSourcesWithStatus fallback path
// ============================================

describe('Rosetta.getSourcesWithStatus() fallback', () => {
	it('builds results manually when getSourcesWithTranslations not available', async () => {
		const storage = createMinimalMockStorage() as StorageAdapter & {
			_insertSource: (h: string, t: string, c?: string) => void;
		};
		storage._insertSource('hash1', 'Hello');
		storage._insertSource('hash2', 'World');
		await storage.saveTranslation('zh-TW', 'hash1', '你好');

		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });
		const result = await rosetta.getSourcesWithStatus(['zh-TW']);

		expect(result).toHaveLength(2);

		const hello = result.find((s) => s.hash === 'hash1');
		const world = result.find((s) => s.hash === 'hash2');

		expect(hello?.translations['zh-TW']).toEqual({
			text: '你好',
			autoGenerated: false,
			reviewed: false,
		});
		expect(world?.translations['zh-TW']).toBeNull();
	});

	it('applies pagination to fallback results', async () => {
		const storage = createMinimalMockStorage() as StorageAdapter & {
			_insertSource: (h: string, t: string) => void;
		};
		storage._insertSource('hash1', 'One');
		storage._insertSource('hash2', 'Two');
		storage._insertSource('hash3', 'Three');

		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });

		// Test limit
		const limited = await rosetta.getSourcesWithStatus(['zh-TW'], { limit: 2 });
		expect(limited).toHaveLength(2);

		// Test offset
		const offset = await rosetta.getSourcesWithStatus(['zh-TW'], { offset: 1 });
		expect(offset).toHaveLength(2);

		// Test both
		const both = await rosetta.getSourcesWithStatus(['zh-TW'], { limit: 1, offset: 1 });
		expect(both).toHaveLength(1);
	});
});

// ============================================
// getTranslationStats fallback
// ============================================

describe('Rosetta.getTranslationStats() fallback', () => {
	it('uses basic stats when getSourcesWithTranslations not available', async () => {
		const storage = createMinimalMockStorage() as StorageAdapter & {
			_insertSource: (h: string, t: string) => void;
		};
		storage._insertSource('hash1', 'Hello');
		storage._insertSource('hash2', 'World');
		await storage.saveTranslation('zh-TW', 'hash1', '你好');

		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });
		const stats = await rosetta.getTranslationStats(['zh-TW']);

		expect(stats.totalStrings).toBe(2);
		expect(stats.locales['zh-TW']).toEqual({
			translated: 1,
			reviewed: 0, // Always 0 in fallback
			total: 2,
		});
	});
});

// ============================================
// detectLocale edge cases
// ============================================

describe('Rosetta.detectLocale() edge cases', () => {
	it('returns default locale when detector returns invalid format', async () => {
		const storage = createFullMockStorage();
		const rosetta = new Rosetta({
			storage,
			defaultLocale: 'en',
			localeDetector: () => 'invalid-locale-format',
		});

		// Should warn in development and return default
		const locale = await rosetta.detectLocale();
		expect(locale).toBe('en');
	});

	it('returns detected locale when valid', async () => {
		const storage = createFullMockStorage();
		const rosetta = new Rosetta({
			storage,
			defaultLocale: 'en',
			localeDetector: () => 'zh-TW',
		});

		const locale = await rosetta.detectLocale();
		expect(locale).toBe('zh-TW');
	});

	it('handles async locale detector', async () => {
		const storage = createFullMockStorage();
		const rosetta = new Rosetta({
			storage,
			defaultLocale: 'en',
			localeDetector: async () => {
				await new Promise((r) => setTimeout(r, 1));
				return 'ja';
			},
		});

		const locale = await rosetta.detectLocale();
		expect(locale).toBe('ja');
	});
});

// ============================================
// generateTranslation error handling
// ============================================

describe('Rosetta.generateTranslation() error handling', () => {
	it('returns null when translator throws', async () => {
		const storage = createFullMockStorage();
		const rosetta = new Rosetta({
			storage,
			translator: createFailingTranslator(),
			defaultLocale: 'en',
		});

		const result = await rosetta.generateTranslation('Hello', 'zh-TW');
		expect(result).toBeNull();
	});
});

// ============================================
// batchTranslate fallback and error handling
// ============================================

describe('Rosetta.batchTranslate() edge cases', () => {
	it('throws when no translator configured', async () => {
		const storage = createFullMockStorage();
		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });

		await expect(
			rosetta.batchTranslate([{ hash: 'h1', text: 'Hello' }], 'zh-TW')
		).rejects.toThrow('No translator adapter configured');
	});

	it('falls back to parallel translation when batch fails', async () => {
		const storage = createFullMockStorage();
		// Create translator that fails batch but succeeds individual
		const translator: TranslateAdapter = {
			async translate(text, options) {
				return `[${options.to}] ${text}`;
			},
			async translateBatch() {
				throw new Error('Batch not supported');
			},
		};

		const rosetta = new Rosetta({ storage, translator, defaultLocale: 'en' });

		const result = await rosetta.batchTranslate(
			[
				{ hash: 'h1', text: 'Hello' },
				{ hash: 'h2', text: 'World' },
			],
			'zh-TW'
		);

		expect(result.success).toBe(2);
		expect(result.failed).toBe(0);
	});

	it('handles mixed success/failure in batch', async () => {
		const storage = createFullMockStorage();
		let callCount = 0;
		const translator: TranslateAdapter = {
			async translate(text, options) {
				callCount++;
				if (callCount % 2 === 0) {
					throw new Error('Translation failed');
				}
				return `[${options.to}] ${text}`;
			},
		};

		const rosetta = new Rosetta({ storage, translator, defaultLocale: 'en' });

		const result = await rosetta.batchTranslate(
			[
				{ hash: 'h1', text: 'One' },
				{ hash: 'h2', text: 'Two' },
				{ hash: 'h3', text: 'Three' },
				{ hash: 'h4', text: 'Four' },
			],
			'zh-TW'
		);

		// Odd calls succeed, even calls fail
		expect(result.success).toBe(2);
		expect(result.failed).toBe(2);
	});
});

// ============================================
// applyPagination
// ============================================

describe('Rosetta.getSourcesWithStatus() pagination', () => {
	it('returns all when no pagination', async () => {
		const storage = createFullMockStorage();
		storage._insertSource('h1', 'One');
		storage._insertSource('h2', 'Two');
		storage._insertSource('h3', 'Three');

		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });
		const result = await rosetta.getSourcesWithStatus(['en']);

		expect(result).toHaveLength(3);
	});

	it('handles negative offset as 0', async () => {
		const storage = createFullMockStorage();
		storage._insertSource('h1', 'One');
		storage._insertSource('h2', 'Two');

		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });
		const result = await rosetta.getSourcesWithStatus(['en'], { offset: -5 });

		expect(result).toHaveLength(2);
	});

	it('handles offset without limit', async () => {
		const storage = createFullMockStorage();
		storage._insertSource('h1', 'One');
		storage._insertSource('h2', 'Two');
		storage._insertSource('h3', 'Three');

		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });
		const result = await rosetta.getSourcesWithStatus(['en'], { offset: 1 });

		expect(result).toHaveLength(2);
	});
});

// ============================================
// generateAllUntranslated with progress
// ============================================

describe('Rosetta.generateAllUntranslated() with progress', () => {
	it('calls progress callback', async () => {
		const storage = createFullMockStorage();
		storage._insertSource('h1', 'One');
		storage._insertSource('h2', 'Two');

		const rosetta = new Rosetta({
			storage,
			translator: createMockTranslator(),
			defaultLocale: 'en',
		});

		const progress: Array<{ current: number; total: number }> = [];
		await rosetta.generateAllUntranslated('zh-TW', (current, total) => {
			progress.push({ current, total });
		});

		expect(progress).toHaveLength(2);
		expect(progress[0]).toEqual({ current: 1, total: 2 });
		expect(progress[1]).toEqual({ current: 2, total: 2 });
	});

	it('tracks failed translations', async () => {
		const storage = createFullMockStorage();
		storage._insertSource('h1', 'One');
		storage._insertSource('h2', 'Two');

		const rosetta = new Rosetta({
			storage,
			translator: createFailingTranslator(),
			defaultLocale: 'en',
		});

		const result = await rosetta.generateAllUntranslated('zh-TW');

		expect(result.success).toBe(0);
		expect(result.failed).toBe(2);
	});
});

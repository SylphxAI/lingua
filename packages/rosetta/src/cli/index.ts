#!/usr/bin/env bun
/**
 * Rosetta CLI
 *
 * Commands:
 *   extract - Extract t() strings from source files
 */

import type { PendingSourceString } from '../types';
import { extract, formatResult } from './extract';

interface CLIOptions {
	/** Root directory to scan */
	root?: string;
	/** Output format: 'json' | 'ts' | 'table' | 'silent' */
	format?: 'json' | 'ts' | 'table' | 'silent';
	/** Verbose output */
	verbose?: boolean;
	/** Dry run (don't save to storage) */
	dryRun?: boolean;
	/** Include patterns */
	include?: string[];
	/** Exclude patterns */
	exclude?: string[];
	/** Output file for JSON or TypeScript */
	output?: string;
	/** Watch mode - re-extract on file changes */
	watch?: boolean;
}

function parseArgs(args: string[]): { command: string; options: CLIOptions } {
	const command = args[0] || 'help';
	const options: CLIOptions = {};

	for (let i = 1; i < args.length; i++) {
		const arg = args[i];

		if (arg === '--root' || arg === '-r') {
			options.root = args[++i];
		} else if (arg === '--format' || arg === '-f') {
			options.format = args[++i] as CLIOptions['format'];
		} else if (arg === '--verbose' || arg === '-v') {
			options.verbose = true;
		} else if (arg === '--dry-run' || arg === '-d') {
			options.dryRun = true;
		} else if (arg === '--include' || arg === '-i') {
			options.include = options.include || [];
			const pattern = args[++i];
			if (pattern) options.include.push(pattern);
		} else if (arg === '--exclude' || arg === '-e') {
			options.exclude = options.exclude || [];
			const pattern = args[++i];
			if (pattern) options.exclude.push(pattern);
		} else if (arg === '--output' || arg === '-o') {
			options.output = args[++i];
		} else if (arg === '--watch' || arg === '-w') {
			options.watch = true;
		}
	}

	return { command, options };
}

/**
 * Escape string for TypeScript single-quoted string literal
 */
function escapeForTS(str: string): string {
	return str.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n');
}

/**
 * Generate TypeScript manifest code from extracted strings
 */
function generateTypeScriptManifest(strings: PendingSourceString[]): string {
	const entries = strings.map((s) => {
		const escapedText = escapeForTS(s.text);
		if (s.context) {
			const escapedContext = escapeForTS(s.context);
			return `  { hash: '${s.hash}', text: '${escapedText}', context: '${escapedContext}' }`;
		}
		return `  { hash: '${s.hash}', text: '${escapedText}' }`;
	});

	return `/**
 * Rosetta Manifest - Auto-generated by rosetta CLI
 * DO NOT EDIT - This file is regenerated on each build
 *
 * Run: rosetta extract -f ts -o src/rosetta/manifest.ts
 */

export const manifest = [
${entries.join(',\n')},
] as const;

export type ManifestEntry = (typeof manifest)[number];
`;
}

function printHelp(): void {
	console.log(`
rosetta - Compile-time i18n string extraction

Usage:
  rosetta <command> [options]

Commands:
  extract    Extract t() strings from source files
  help       Show this help message

Options:
  --root, -r <path>      Root directory to scan (default: cwd)
  --format, -f <format>  Output format: json, ts, table, silent (default: table)
  --output, -o <file>    Output to file (format inferred from extension if not set)
  --watch, -w            Watch mode - re-extract on file changes
  --verbose, -v          Show verbose output
  --dry-run, -d          Don't save to storage, just show results
  --include, -i <glob>   Include pattern (can be used multiple times)
  --exclude, -e <glob>   Exclude pattern (can be used multiple times)

Examples:
  rosetta extract
  rosetta extract --root ./src --verbose
  rosetta extract -o src/rosetta/manifest.ts
  rosetta extract -o src/rosetta/manifest.ts --watch
`);
}

async function doExtract(options: {
	root: string;
	verbose?: boolean;
	include?: string[];
	exclude?: string[];
	output?: string;
	format: 'json' | 'ts' | 'table' | 'silent';
}): Promise<number> {
	const { root, verbose, include, exclude, output, format } = options;

	const result = await extract({
		root,
		verbose,
		include,
		exclude,
	});

	if (output) {
		// Write to file based on format
		const content =
			format === 'ts'
				? generateTypeScriptManifest(result.strings)
				: JSON.stringify(result.strings, null, 2);

		await Bun.write(output, content);
		console.log(`[rosetta] Extracted ${result.strings.length} strings to ${output}`);
	} else if (format === 'json') {
		console.log(JSON.stringify(result.strings, null, 2));
	} else if (format === 'ts') {
		console.log(generateTypeScriptManifest(result.strings));
	} else if (format === 'table') {
		console.log(formatResult(result));

		if (result.strings.length > 0 && verbose) {
			console.log('\nStrings:');
			for (const str of result.strings) {
				console.log(
					`  [${str.hash}] ${str.text.substring(0, 60)}${str.text.length > 60 ? '...' : ''}`
				);
			}
		}
	}

	return result.strings.length;
}

async function runExtract(options: CLIOptions): Promise<void> {
	const { root = process.cwd(), verbose, include, exclude, output, watch } = options;
	let { format = 'table' } = options;

	// Infer format from output file extension if not explicitly set
	if (output && format === 'table') {
		if (output.endsWith('.ts')) {
			format = 'ts';
		} else if (output.endsWith('.json')) {
			format = 'json';
		}
	}

	if (verbose) {
		console.log('Extracting strings...\n');
	}

	// Initial extraction
	await doExtract({ root, verbose, include, exclude, output, format });

	// Watch mode
	if (watch) {
		if (!output) {
			console.error('[rosetta] --watch requires --output to be set');
			process.exit(1);
		}

		console.log('[rosetta] Watching for changes... (Ctrl+C to stop)');

		const { watch: fsWatch } = await import('node:fs');

		// Debounce to avoid multiple rapid extractions
		let debounceTimer: ReturnType<typeof setTimeout> | null = null;
		const DEBOUNCE_MS = 100;

		const patterns = include ?? ['**/*.tsx', '**/*.ts', '**/*.jsx', '**/*.js'];
		const excludePatterns = exclude ?? [
			'**/node_modules/**',
			'**/.next/**',
			'**/dist/**',
			'**/*.d.ts',
		];

		// Watch the root directory recursively
		fsWatch(root, { recursive: true }, (_eventType, filename) => {
			if (!filename) return;

			// Check if file matches include patterns
			const matchesInclude = patterns.some((pattern) => {
				const glob = new Bun.Glob(pattern);
				return glob.match(filename);
			});

			if (!matchesInclude) return;

			// Check if file matches exclude patterns
			const matchesExclude = excludePatterns.some((pattern) => {
				const glob = new Bun.Glob(pattern);
				return glob.match(filename);
			});

			if (matchesExclude) return;

			// Skip the output file itself
			if (output && filename.endsWith(output.split('/').pop() || '')) return;

			// Debounce
			if (debounceTimer) clearTimeout(debounceTimer);
			debounceTimer = setTimeout(async () => {
				if (verbose) {
					console.log(`[rosetta] Change detected: ${filename}`);
				}
				await doExtract({ root, verbose: false, include, exclude, output, format });
			}, DEBOUNCE_MS);
		});

		// Keep the process running
		await new Promise(() => {});
	}
}

async function main(): Promise<void> {
	const args = process.argv.slice(2);
	const { command, options } = parseArgs(args);

	switch (command) {
		case 'extract':
			await runExtract(options);
			break;
		case 'help':
		case '--help':
		case '-h':
			printHelp();
			break;
		default:
			console.error(`Unknown command: ${command}`);
			printHelp();
			process.exit(1);
	}
}

main().catch((error) => {
	console.error('Error:', error);
	process.exit(1);
});

export { extract, formatResult } from './extract';
export type { ExtractOptions, ExtractResult } from './extract';
export type { CLIOptions };

import type { Rosetta } from '@sylphx/rosetta/server';
import { buildLocaleChain, runWithRosetta } from '@sylphx/rosetta/server';
import fs from 'node:fs';
import path from 'node:path';
import type { ReactNode } from 'react';
import { RosettaClientProvider } from './client';

// Re-export locale utilities
export {
	getReadyLocales,
	buildLocaleCookie,
	parseLocaleCookie,
	LOCALE_COOKIE_NAME,
	LOCALE_COOKIE_MAX_AGE,
	type LocaleConfig,
	type LocaleEntry,
	type LocaleWithStats,
	type GetReadyLocalesOptions,
	type LocaleCookieOptions,
} from './locale';

// ============================================
// Route Manifest Helpers
// ============================================

const ROUTES_FILE = '.rosetta/routes.json';
let cachedRoutes: Record<string, string[]> | null = null;

/**
 * Read route manifest from .rosetta/routes.json
 * Cached after first read for performance
 */
function readRoutesManifest(): Record<string, string[]> {
	if (cachedRoutes !== null) {
		return cachedRoutes;
	}

	const routesPath = path.join(process.cwd(), ROUTES_FILE);

	try {
		if (fs.existsSync(routesPath)) {
			const content = fs.readFileSync(routesPath, 'utf-8');
			cachedRoutes = JSON.parse(content);
			return cachedRoutes!;
		}
	} catch {
		// Ignore errors, fall back to loading all
	}

	cachedRoutes = {};
	return cachedRoutes;
}

/**
 * Get hashes for a specific route (with _shared fallback)
 */
function getHashesForRoute(pathname: string): string[] | null {
	const routes = readRoutesManifest();

	// No routes manifest - load all
	if (Object.keys(routes).length === 0) {
		return null;
	}

	// Normalize pathname (remove trailing slash, handle index)
	let route = pathname === '' ? '/' : pathname;
	if (route !== '/' && route.endsWith('/')) {
		route = route.slice(0, -1);
	}

	// Find matching route (exact match first, then try parent routes)
	let routeHashes = routes[route];

	// If no exact match, try removing dynamic segments
	// e.g., /products/123 → /products/[id] → /products
	if (!routeHashes) {
		const parts = route.split('/').filter(Boolean);
		while (parts.length > 0 && !routeHashes) {
			// Try with [param] pattern
			const parentRoute = '/' + parts.slice(0, -1).join('/');
			routeHashes = routes[parentRoute] || routes[parentRoute || '/'];
			parts.pop();
		}
	}

	// Include _shared strings (used across routes)
	const sharedHashes = routes['_shared'] || [];

	if (!routeHashes && sharedHashes.length === 0) {
		return null;
	}

	// Combine and deduplicate
	return [...new Set([...(routeHashes || []), ...sharedHashes])];
}

// ============================================
// Types
// ============================================

/**
 * Translation manifest mapping routes to required hashes
 * Generated by build plugin for fine-grained loading
 */
export type RosettaManifest = Record<string, string[]>;

export interface RosettaProviderProps {
	/** Rosetta instance */
	rosetta: Rosetta;
	/** Current locale (e.g., from URL params) */
	locale: string;
	/** Children to render */
	children: ReactNode;
	/**
	 * Current pathname for page-level optimization
	 * If provided, only translations for this route are loaded
	 * If not provided, checks .rosetta/routes.json automatically
	 */
	pathname?: string;
	/**
	 * Specific hashes to load (fine-grained loading)
	 * If provided, overrides pathname-based loading
	 * If not provided, uses pathname or loads all translations
	 */
	hashes?: string[];
	/**
	 * Route manifest for page-level optimization
	 * If provided, uses this instead of reading from .rosetta/routes.json
	 */
	routes?: RosettaManifest;
}

// ============================================
// Server Provider
// ============================================

/**
 * RosettaProvider - Server component that sets up translation context
 *
 * This is an async server component that:
 * 1. Loads translations for the specified locale
 * 2. Sets up AsyncLocalStorage context for server components
 * 3. Provides React context for client components via RosettaClientProvider
 *
 * **Page-Level Optimization (Zero-Config):**
 * When using `withRosetta()` in next.config.ts, a routes.json is generated
 * during build that maps routes to their required translation hashes.
 * RosettaProvider automatically uses this to load only the translations
 * needed for the current page.
 *
 * IMPORTANT: This component does NOT auto-sync strings to the database.
 * Use `syncRosetta()` in your deployment pipeline:
 *
 * ```bash
 * npm run build && npm run rosetta:sync && npm run start
 * ```
 *
 * @example
 * // Zero-config - automatic page-level optimization
 * // app/[locale]/layout.tsx
 * import { RosettaProvider } from '@sylphx/rosetta-next/server';
 * import { rosetta } from '@/lib/i18n';
 *
 * export default async function Layout({ children, params }) {
 *   return (
 *     <RosettaProvider rosetta={rosetta} locale={params.locale}>
 *       <html lang={params.locale}>
 *         <body>{children}</body>
 *       </html>
 *     </RosettaProvider>
 *   );
 * }
 *
 * @example
 * // With explicit pathname (for nested layouts)
 * import { headers } from 'next/headers';
 *
 * export default async function Layout({ children, params }) {
 *   const pathname = headers().get('x-pathname') || '/';
 *   return (
 *     <RosettaProvider rosetta={rosetta} locale={params.locale} pathname={pathname}>
 *       {children}
 *     </RosettaProvider>
 *   );
 * }
 *
 * @example
 * // In server components - use t() directly
 * import { t } from '@sylphx/rosetta/server';
 * function MyComponent() {
 *   return <h1>{t("Hello World")}</h1>;
 * }
 *
 * @example
 * // In client components - use useT hook
 * 'use client';
 * import { useT } from '@sylphx/rosetta-next';
 * function MyButton() {
 *   const t = useT();
 *   return <button>{t("Click me")}</button>;
 * }
 */
export async function RosettaProvider({
	rosetta,
	locale,
	children,
	pathname,
	hashes,
	routes,
}: RosettaProviderProps): Promise<React.ReactElement> {
	// Determine which hashes to load
	let hashesToLoad: string[] | undefined = hashes;

	// If no explicit hashes, try route-based optimization
	if (!hashesToLoad && pathname) {
		// Use provided routes or read from filesystem
		if (routes) {
			const routeHashes = routes[pathname] || [];
			const sharedHashes = routes['_shared'] || [];
			if (routeHashes.length > 0 || sharedHashes.length > 0) {
				hashesToLoad = [...new Set([...routeHashes, ...sharedHashes])];
			}
		} else {
			hashesToLoad = getHashesForRoute(pathname) || undefined;
		}
	}

	// Load translations - fine-grained if hashes available, otherwise all
	// Translations are already merged from fallback chain (zh-TW → zh → en)
	const translations = hashesToLoad
		? await rosetta.loadTranslationsByHashes(locale, hashesToLoad)
		: await rosetta.loadTranslations(locale);
	const defaultLocale = rosetta.getDefaultLocale();
	const localeChain = buildLocaleChain(locale, defaultLocale);

	// Run within AsyncLocalStorage context for server components
	// and provide React context for client components
	return runWithRosetta(
		{
			locale,
			defaultLocale,
			localeChain,
			translations,
			storage: rosetta.getStorage(),
		},
		() => (
			<RosettaClientProvider
				locale={locale}
				defaultLocale={defaultLocale}
				translations={Object.fromEntries(translations)}
			>
				{children}
			</RosettaClientProvider>
		)
	);
}

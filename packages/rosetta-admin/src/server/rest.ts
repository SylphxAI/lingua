/**
 * REST API handlers for translation admin
 *
 * Works with Edge runtime - no fs.readFile needed.
 *
 * @example Next.js App Router (Edge compatible)
 * ```ts
 * // 1. Generate manifest in build script:
 * //    "build": "rosetta extract -o src/rosetta/manifest.ts && next build"
 *
 * // 2. app/api/admin/translations/route.ts
 * import { createRestHandlers } from '@sylphx/rosetta-admin/server';
 * import { manifest } from '@/rosetta/manifest';
 * import { storage } from '@/lib/rosetta';
 *
 * const handlers = createRestHandlers({
 *   storage,
 *   getManifestSources: async () => manifest,
 * });
 *
 * export const { GET, PUT, PATCH } = handlers;
 * ```
 */

import type { AdminServiceConfig } from './service';
import { createAdminService } from './service';

export interface RestHandlersConfig extends AdminServiceConfig {
	/**
	 * Authorization function (optional)
	 * Return false to reject the request
	 */
	authorize?: (request: Request) => Promise<boolean>;
}

export interface RestHandlers {
	/** GET: Fetch translations, stats, locales */
	GET: (request: Request) => Promise<Response>;
	/** PUT: Save a single translation */
	PUT: (request: Request) => Promise<Response>;
	/** PATCH: Mark as reviewed */
	PATCH: (request: Request) => Promise<Response>;
	/** POST: Batch translate */
	batchTranslate: (request: Request) => Promise<Response>;
}

/**
 * Create REST API handlers
 */
export function createRestHandlers(config: RestHandlersConfig): RestHandlers {
	const { authorize, ...serviceConfig } = config;
	const service = createAdminService(serviceConfig);

	async function checkAuth(request: Request): Promise<Response | null> {
		if (authorize) {
			const authorized = await authorize(request);
			if (!authorized) {
				return Response.json({ error: 'Unauthorized' }, { status: 401 });
			}
		}
		return null;
	}

	return {
		async GET(request: Request): Promise<Response> {
			const authError = await checkAuth(request);
			if (authError) return authError;

			try {
				const data = await service.fetchTranslations();
				return Response.json(data);
			} catch (error) {
				console.error('Failed to fetch translations:', error);
				return Response.json({ error: 'Failed to fetch translations' }, { status: 500 });
			}
		},

		async PUT(request: Request): Promise<Response> {
			const authError = await checkAuth(request);
			if (authError) return authError;

			try {
				const body = await request.json();
				const { sourceHash, locale, translatedText, autoGenerated, translatedFrom } = body;

				if (!sourceHash || !locale || translatedText === undefined) {
					return Response.json(
						{ error: 'sourceHash, locale, and translatedText are required' },
						{ status: 400 }
					);
				}

				await service.saveTranslation({
					sourceHash,
					locale,
					translatedText,
					autoGenerated,
					translatedFrom,
				});

				return Response.json({ success: true });
			} catch (error) {
				console.error('Failed to save translation:', error);
				return Response.json({ error: 'Failed to save translation' }, { status: 500 });
			}
		},

		async PATCH(request: Request): Promise<Response> {
			const authError = await checkAuth(request);
			if (authError) return authError;

			try {
				const body = await request.json();
				const { sourceHash, locale } = body;

				if (!sourceHash || !locale) {
					return Response.json({ error: 'sourceHash and locale are required' }, { status: 400 });
				}

				await service.markAsReviewed({ sourceHash, locale });

				return Response.json({ success: true });
			} catch (error) {
				console.error('Failed to mark as reviewed:', error);
				return Response.json({ error: 'Failed to mark as reviewed' }, { status: 500 });
			}
		},

		async batchTranslate(request: Request): Promise<Response> {
			const authError = await checkAuth(request);
			if (authError) return authError;

			try {
				const body = await request.json();
				const { locale, hashes } = body;

				if (!locale || locale === 'en') {
					return Response.json({ error: 'Valid non-English locale is required' }, { status: 400 });
				}

				// Check if client accepts SSE
				const acceptHeader = request.headers.get('Accept') || '';
				const wantsStream = acceptHeader.includes('text/event-stream');

				if (wantsStream) {
					// Return SSE stream
					const stream = new ReadableStream({
						async start(controller) {
							const encoder = new TextEncoder();

							function sendEvent(data: unknown) {
								const message = `data: ${JSON.stringify(data)}\n\n`;
								controller.enqueue(encoder.encode(message));
							}

							try {
								for await (const event of service.batchTranslateStream({ locale, hashes })) {
									sendEvent(event);
								}
							} catch (err) {
								sendEvent({
									type: 'error',
									message: err instanceof Error ? err.message : 'Stream failed',
								});
							} finally {
								controller.close();
							}
						},
					});

					return new Response(stream, {
						headers: {
							'Content-Type': 'text/event-stream',
							'Cache-Control': 'no-cache',
							Connection: 'keep-alive',
						},
					});
				}

				// Fallback: non-streaming response
				const result = await service.batchTranslate({ locale, hashes });
				return Response.json(result);
			} catch (error) {
				console.error('Batch translation failed:', error);
				return Response.json(
					{ error: error instanceof Error ? error.message : 'Batch translation failed' },
					{ status: 500 }
				);
			}
		},
	};
}
